#include "Horizon.h"
#include "NUPlatform/NUCamera.h"
#include <cmath>
#include "Kinematics.h"

Horizon::Horizon()
{
  Reset();
  return;
}

Horizon::~Horizon()
{
  return;
}

void Horizon::Reset(){
    exists = false;
    return;
}

//void Horizon::Calculate(double bodyPitch, double bodyRoll, double headYaw, double headPitch, int cameraNumber)
//// Calculate the two edge ponts on the screen at which the horizon line intersects. Maths based on the 2005 German Team AIBO report.
//{
//    double s = 320/2.0;
//    double alpha = (0.7854/2.0);
//    // Equations generated by multiplying the y and z components of a 3D rotation matrix together
//    double cotAlpha;
//    if(tan(alpha) == 0)
//        cotAlpha = 10000000;
//    else
//        cotAlpha = 1.0/tan(alpha);

//    if(cameraNumber == 1)
//        headPitch += 0.6981 + NUCamera::CameraOffset;
    
//    //headPitch += 0.068/2;               // offsets measured through experiment 1/6/2010 for nubot2
//    //bodyPitch += 0.068/2;

////  2008 Values ... I think they were wrong...
////  float r31 = sin(headYaw)*sin(bodyRoll)+(cos(headYaw)*cos(headTilt)*sin(bodyTilt)+cos(headYaw)*sin(headTilt)*cos(bodyTilt))*cos(bodyRoll);
////    float r32 = -cos(headYaw)*sin(bodyRoll)+(sin(headYaw)*cos(headTilt)*sin(bodyTilt)+sin(headYaw)*sin(headTilt)*cos(bodyTilt))*cos(bodyRoll);
////    float r33 = (-sin(headTilt)*sin(bodyTilt)+cos(headTilt)*cos(bodyTilt))*cos(bodyRoll);



//headPitch += 0.068/2;               // offsets measured through experiment 1/6/2010 for nubot2
//bodyPitch += 0.068/2;

//  2008 Values ... I think they were wrong...
//  float r31 = sin(headYaw)*sin(bodyRoll)+(cos(headYaw)*cos(headTilt)*sin(bodyTilt)+cos(headYaw)*sin(headTilt)*cos(bodyTilt))*cos(bodyRoll);
//    float r32 = -cos(headYaw)*sin(bodyRoll)+(sin(headYaw)*cos(headTilt)*sin(bodyTilt)+sin(headYaw)*sin(headTilt)*cos(bodyTilt))*cos(bodyRoll);
//    float r33 = (-sin(headTilt)*sin(bodyTilt)+cos(headTilt)*cos(bodyTilt))*cos(bodyRoll);
//// 2009 Values ->  Moved the pan rotation to start, since head pan is not effected by head tilt in Nao.
//    double r31 = cos(bodyRoll)*(cos(bodyPitch)*sin(headPitch) + cos(headYaw)*cos(headPitch)*sin(bodyPitch)) - cos(headPitch)*sin(bodyRoll)*sin(headYaw);
//    double r32 = cos(bodyRoll)*sin(bodyPitch)*sin(headYaw) + cos(headYaw)*sin(bodyRoll);
//    double r33 = cos(bodyRoll)*(cos(bodyPitch)*cos(headPitch) - cos(headYaw)*sin(bodyPitch)*sin(headPitch)) + sin(bodyRoll)*sin(headYaw)*sin(headPitch);

////    Old 210 AIBO Equations
////    float r31 = -cos(bodyRoll)*sin(headPitch)*cos(headYaw) + sin(bodyRoll)*sin(headPitch);
////    float r32 = cos(bodyRoll)*sin(headPitch)*sin(headYaw)+sin(bodyRoll)*cos(headYaw);
////    float r33 = cos(bodyRoll)*cos(headPitch);

//    if(r33 == 0) r33 = 0.00001;
//// Old calculation.
////    float zl = IMAGE_HEIGHT/2 + s*(r32  + r31*cotAlpha)/r33;
////    float zr = IMAGE_HEIGHT/2 + s*(-r32 + r31*cotAlpha)/r33;
//    Point zl,zr;
//    zl.x = 0;
//    zl.y = 240/2 - s*(-r32  + r31*cotAlpha)/r33;
//    zr.x = 320;
//    zr.y = 240/2 - s*(r32 + r31*cotAlpha)/r33;
//    setLineFromPoints(zl,zr);
////    std::cout << "Horizon: zl = " << zl.y << " zr = " << zr.y << std::endl;
//    exists = true;
//    return;
//}

void Horizon::Calculate(const Matrix& cameraToGroundTransform, const Vector2<double>& cameraFieldOfView, const Vector2<double> &imageDimensions)
// Calculate the two edge ponts on the screen at which the horizon line intersects. Maths based on the 2005 German Team AIBO report.
{
    Matrix invCTG = InverseMatrix(cameraToGroundTransform);

    Vector3<double> g1(5000, cameraFieldOfView.x*0.5, 0),
                    g2(5000, -cameraFieldOfView.x*0.5, 0);

    Vector3<double> c1 = Kinematics::TransformPosition(invCTG, g1),
                    c2 = Kinematics::TransformPosition(invCTG, g2);

    Vector2<double> tanRadial1(tan(c1.y), tan(c1.z)),
                    tanRadial2(tan(c2.y), tan(c2.z));

    Vector2<double> imageCentre = imageDimensions*0.5;
    Vector2<double> tanHalfFOV(tan(cameraFieldOfView.x*0.5), tan(cameraFieldOfView.y*0.5));
    Vector2<double> radialToScreenFactor = imageCentre.elemDiv(tanHalfFOV);

    Vector2<double> pixel1 = imageCentre - radialToScreenFactor.elemMult(tanRadial1),
                    pixel2 = imageCentre - radialToScreenFactor.elemMult(tanRadial2);

    setLineFromPoints(pixel1, pixel2);
    exists = true;
}

bool Horizon::IsBelowHorizon(int x, int y) const{
    return findYFromX(x) < y;
}
